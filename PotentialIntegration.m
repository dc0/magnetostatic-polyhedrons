(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



On[Assert];
$Path=Union[Append[$Path,NotebookDirectory[]]];
<<SmolyakQuadrature`


ClearAll[g,grad,vol,rp,r,surf,id,tr,rot,rank,surf,line,disp,R,idR,A,B,surf2,\[ScriptCapitalI],\[ScriptCapitalL],\[Mu],\[Xi]]
(* rank of a tensor (only applies to homogeneous tensors) *)
(* explicit ranks for certain variables *)
rank[(g|A|B)[_]]:=0
rank[_?NumberQ]:=0
rank[r|rp|r0|Subscript[n, _]|R[_]|Subscript[\[ScriptL], _]|ntria[_]|R]:=1
rank[Subscript[(\[ScriptCapitalI]|\[ScriptCapitalL]|\[Mu]|\[Xi]), k_]]:=k
rank[id]:=2
(* ranks of derived expressions *)
rank::product:="Commutative product of non-scalars `1` and `2` not allowed"
rank[a_ b_]:=If[rank[a]===0||rank[b]===0,rank[a]+rank[b],Message[rank::product, a, b];Abort[]]
rank[1/a_]/;rank[a]==0:=0
rank[Subscript[grad, a_][b_]]:=rank[a] + rank[b]
rank[Subscript[curl, r_][a_]]/;rank[r]==1&&rank[a]>=1:=rank[a]
rank[Del[a_]]:=rank[a[r]] + 1
rank[Subscript[tr, __][a_]]:=rank[a]-2
rank[Subscript[rot, __][a_]]:=rank[a]
rank[a_**b_]:=rank[a]+rank[b]
rank[a_\[Diamond]b_]/;rank[a]==1:=rank[b]
rank[a_List]/;Length[a]>0&&SameQ@@(rank/@a):=rank[a[[1]]]+1
rank::sum:="Inhomogeneous sum of tensors `1` (rank=`2`) and `3` (rank=`4`) of ranks not allowed"
rank[a_+b_]:=If[rank[a]===rank[b],rank[a],Message[rank::sum, a, rank[a],b,rank[b]];Abort[]]
rank[Subscript[(surf|surff|vol|line), _][a_]]:=rank[a]


(* Nicer output *)
ClearAll[disp]
disp[x_]:=x//.{
Subscript[grad, r_][a_]:>Subscript[\!\(\*
StyleBox["\[EmptyDownTriangle]",
StripOnInput->False,
FontSize->14,
FontWeight->Bold]\), r][a],
A[r]:>A,
B[rp]:>B,
g[r-rp]:>g,
Subscript[tr, 1,2][a_**b_]/;rank[a]==1&&rank[b]==1:>CircleDot[a,b]
}/.NonCommutativeMultiply->CircleTimes/.rp:>r'



(* Verification functions *)
ClearAll[checkEqual,checkTensor,checkTransform,checkEval,surftri,normalise,normal,limits,sumValues,tet,tria,point,lin,mygrad,transformAll]
checkEqual::unequal:="Expressions `1` and `2`  are not equal: `3` != `4`"
checkEqual[a_,b_]:=With[{va:=Evaluate[a],vb:=Evaluate[b]}, If[va=!=vb,Message[checkEqual::unequal,Unevaluated[a],Unevaluated[b],va, vb];Abort[]]]
SetAttributes[checkEqual,HoldAll];
(* Checking the equality of two tensors *)
checkTensor::nan:="Evaluation did not yield a number: 
    `1`=`2`
    `3`=`4`"
checkTensor::unequal:="Tensors not equal: \[Epsilon]=`1`, 
    `2`=`4`
    `3`=`5`
"
checkTensor[a_,b_,maxAllowedError_:10.^-5]:=Module[{
maxTimeSec=0.05,
maxIter=10,
startTime=SessionTime[],
rpRadius=20,
rpRadius2=40,
cell
},
(* check that the ranks match *)
checkEqual[rank[a],rank[b]];
cell=PrintTemporary[StringForm["Checking the tensor equality `1` == `2`...",a,b]];
(* Print[StringForm["Checking the tensor equality `1` == `2`...",a,b]]; *)
SeedRandom[1];
(* iterate the tests *)
Block[{nIter=0,maxError=0},
While[nIter<maxIter,
Block[{tet,point,lin,tria,ntria},
(* random point outside *)
point[v_]:=point[v]=Block[{tt={0}},While[Norm[tt]<rpRadius,tt=RandomReal[{-rpRadius2,rpRadius2},{3}]];tt];
(* first tetrahedron on (-1,1) *)
tet[r]:=tet[r]=RandomReal[{-1,1},{4,3}];
tria[r]:=tria[r]=RandomReal[{-1,1},{3,3}];
ntria[r_]:=normal[tria[r]];
(* second tetrahedron outside *)
tet[rp]:=tet[rp]=Block[{tt={0},tp=RandomReal[{-1,1},{4,3}]},While[Norm[tt]<rpRadius,tt=RandomReal[{-rpRadius2,rpRadius2},{3}]];tt+#&/@tp];
(* random linear function *)
lin[op_]:=lin[op]=Function@@{RandomReal[{-1,1}]+RandomReal[{-1,1},3].{#1,#2,#3}};
Module[{valA,valB,relerror},
valA=sumValues[Reap[checkEval[a]]];
valB=sumValues[Reap[checkEval[b]]];
checkEqual[TensorRank[valA],TensorRank[valB]];
relerror=Norm[Flatten[{valA-valB}]]/Norm[Flatten[{valA}]];
If[!NumberQ[relerror],Message[checkTensor::nan,a,valA,b,valB];Abort[]];
If[relerror>maxAllowedError,Message[checkTensor::unequal,relerror,a, b,valA,valB];Abort[]];
maxError=Max[relerror,maxError]
]
];
nIter++;
If[SessionTime[]>startTime+maxTimeSec,Break[]];
];
Print[StringForm["Checked (\[Epsilon]=`3`, nIter=`5`) that `1`==`2` in `4` s" ,disp[a],disp[b], NumberForm[maxError,2],NumberForm[SessionTime[]-startTime,2],nIter]];
NotebookDelete[cell]
]
]
transformAll[a_,rules_,rr__]:=transformAll[a//.rules,rr]
transformAll[a_,rules_]:=a//.rules
checkTransform[a_,rules__]:=checkTensor[a,transformAll[a,rules]]
(* gradient that puts the derivative indices at the front *)
mygrad[a_List,b_]:=With[{k=Length[Dimensions[a]]+1},Transpose[Grad[a,b],Permute[Range[k],InversePermutation[Cycles[{Range[k]}]]]]]
mygrad[a_,b_]:=Grad[a,b]
(* evaluation *)
limits[r]:={x,y,z}
limits[rp]:={xp,yp,zp}
intTriSurfWeights[tri_]:=With[{nn=normal[tri]},{#[[1]],Join[#[[2]],nn]}&/@intTriWeights[tri]]
intLineWeights[{r1_,r2_}]=List@@N[gw[10,20]]/.c_ f[a_]:>{c Norm[r2-r1],Expand[a r1+(1-a) r2]};
intLineSurfWeights[line_]:=With[{nn=normalise[line[[2]]-line[[1]]]},{#[[1]],Join[#[[2]],nn]}&/@intLineWeights[line]]
(* volume integral over a tetrahedral *)
checkEval[Subscript[vol, r_][a_]]:=Module[{xx,yy,zz},
Sow[over[{xx,yy,zz},intTetWeights[tet[r]]]];
checkEval[a]/.Thread[limits[r]->{xx,yy,zz}]]
(* integral over the surface of a tetrahedral *)
checkEval[Subscript[surf, r_][a_]]:=Module[{xx,yy,zz,nx,ny,nz},
Sow[over[{xx,yy,zz,nx,ny,nz},Join@@(intTriSurfWeights[tet[r][[#]]]&/@{{1,2,3},{1,4,2},{2,4,3},{1,3,4}})]];
checkEval[a]/.Thread[{n[r,1],n[r,2],n[r,3]}->{nx,ny,nz}]/.Thread[limits[r]->{xx,yy,zz}]]
(* integral over a triangle *)
checkEval[Subscript[surff, r_][a_]]:=Module[{xx,yy,zz,nx,ny,nz},
Sow[over[{xx,yy,zz,nx,ny,nz},intTriSurfWeights[tria[r]]]];
checkEval[a]/.Thread[{n[r,1],n[r,2],n[r,3]}->{nx,ny,nz}]/.Thread[limits[r]->{xx,yy,zz}]]
(* integral over the outline of a triangle *)
checkEval[Subscript[line, r_][a_]]:=Module[{xx,yy,zz,lx,ly,lz},
Sow[over[{xx,yy,zz,lx,ly,lz},Join@@(intLineSurfWeights[tria[r][[#]]]&/@{{1,2},{2,3},{3,1}})]];
checkEval[a]/.Thread[{l[r,1],l[r,2],l[r,3]}->{lx,ly,lz}]/.Thread[limits[r]->{xx,yy,zz}]]
checkEval[Subscript[tr, 1,2][a_]]:=TensorContract[checkEval[a],{{1,2}}]
checkEval[a_ b_]:=checkEval[a] checkEval[b]
checkEval[Power[a_,k_Integer]]/;rank[a]==0:=checkEval[a]^k
checkEval[a_+b_]:=checkEval[a]+checkEval[b]
checkEval[a_**b_]:=TensorProduct[checkEval[a],checkEval[b]]
checkEval[a_List]:=a
checkEval[a_?NumberQ]:=a
checkEval::tensorrank:="Insufficient tensor rank for rotation `1` for `2`"
checkEval[Subscript[rot, a__][b_]]:=With[{vb=checkEval[b]},
If[(TensorRank[vb]>=Max[a])=!=True,Message[checkEval::tensorrank,{a},vb];Abort[]];
TensorTranspose[vb,Permute[Range[Max[a]],InversePermutation[Cycles[{{a}}]]]]
]
checkEval[a:(r|rp)]:=limits[a]
checkEval[(op:A|B)[a_]]:=lin[op]@@checkEval[a]
checkEval[Del[(op:A|B)]]:=lin[op]@@IdentityMatrix[3]-lin[op]@@ConstantArray[0,{3,3}]
checkEval[r0]:=point[r0]
checkEval[Subscript[n, r0]]:=point[Subscript[n, r0]]
checkEval[a_\[Diamond]b_]:=With[{va=checkEval[a],vb=checkEval[b]},
{-va[[3]] vb[[2]]+va[[2]] vb[[3]],va[[3]] vb[[1]]-va[[1]] vb[[3]],-va[[2]] vb[[1]]+va[[1]] vb[[2]]}
]
checkEval[Subscript[grad, r_][a_]]:=mygrad[checkEval[a],limits[r]]
checkEval[Subscript[curl, r_][a_]]/;rank[a]==1:=Curl[checkEval[a],limits[r]]
checkEval[Subscript[n, r_]]:=Table[n[r,i],{i,3}]
checkEval[Subscript[\[ScriptL], r_]]:=Table[l[r,i],{i,3}]
checkEval[g[r_]]/;rank[r]==1:=With[{a=checkEval[r]},1/Sqrt[a.a]]
(* Some 3d operations *)
normalise[v_]:=v/Norm[v]
normal[tri_]:=normalise[Cross[tri[[2]]-tri[[1]],tri[[3]]-tri[[1]]]]
surftri[f_,r_,tri_]:=intTri[Function@@{f/.Subscript[n, r]->-normal[tri]/.Thread[limits[r]->{#1,#2,#3}]},tri]

ClearAll[joinargs]
joinargs[{w1_,r1_},{w2_,r2_}]:={w1 w2,Join[r1,r2]}
joinargs[{w1_,r1_}]:={w1,r1}
sumValues[{a_,{}}]:=a
sumValues[{a_,{rs_}}]:=Module[{vars,func,ws},
vars=Flatten[rs[[All,1]]];
func=Compile[Evaluate[vars],{a}];
ws=List@@Distribute[f@@(g@@#&/@rs[[All,2,All]]),g]/.f->joinargs;
Total[#[[1]] func@@#[[2]]&/@ws]
]


(* Testing only *)
ClearAll[tet,tri,lin,tria,testEval,surfEval]
testEval[a_,extraSubs_:{}]:=Block[{
rpRadius=20,
rpRadius2=40,
point,
tet,
tria,
lin,
ntria
},
SeedRandom[1];
point[v_]:=point[v]=Block[{tt={0}},While[Norm[tt]<rpRadius,tt=RandomReal[{-rpRadius2,rpRadius2},{3}]];tt];
tet[r]:=tet[r]=RandomReal[{-1,1},{4,3}];
tet[rp]:=tet[rp]=Block[{tt={0},tp=RandomReal[{-1,1},{4,3}]},While[Norm[tt]<rpRadius,tt=RandomReal[{-rpRadius2,rpRadius2},{3}]];tt+#&/@tp];
tria[r]:=tria[r]=RandomReal[{-1,1},{3,3}];
ntria[r_]:=normal[tria[r]];
lin[op_]:=lin[op]=Function@@{RandomReal[{-1,1}]+RandomReal[{-1,1},3].{#1,#2,#3}};
sumValues@Reap@checkEval[a/.extraSubs]
]
surfEvalRules:={Subscript[n, r]:>ntria[r]}
surfTransform[a_,rules__]:=checkTensor[a/.surfEvalRules,transformAll[a,rules]/.surfEvalRules]
surfEval[a_]:=testEval[a,surfEvalRules]
surfEval[a_+b_]:=surfEval[a]+surfEval[b]


(* Rules needed for a volume\[Rule]surface integral reduction *)
ClearAll[moveLinearOutside,moveOpOutside,simplifications,moveOpInside,integrateG]
moveLinearOutside[int_]:={
Subscript[int, r_][a_**b_]/;FreeQ[a,r]:>a**Subscript[int, r][b],
Subscript[int, r_][a_**b_]/;FreeQ[b,r]:>Subscript[int, r][a]**b,
Subscript[int, r_][c_ a_**b_]/;FreeQ[a,r]:>a**Subscript[int, r][c b],
Subscript[int, r_][c_ a_**b_]/;FreeQ[b,r]:>Subscript[int, r][c a]**b,
Subscript[int, r_][a_ b_]/;FreeQ[a,r]:>a Subscript[int, r][b],
Subscript[int, r_][a_+b_]:>Subscript[int, r][a]+Subscript[int, r][b],
(* keep g(r-r')^k inside the integral *)
Subscript[int, rr_][c_(a_+b_)]/;a+b=!=r-rp:>Subscript[int, rr][c a]+Subscript[int, rr][c b],
Subscript[int, r_]@Subscript[(op:tr|rot), v__]@a_:>Subscript[op, v]@Subscript[int, r]@a,
Subscript[int, r_]@Subscript[grad, rp_]@a_/;FreeQ[rp,r]:>Subscript[grad, rp]@Subscript[int, r]@a
}
moveLinearInside[int_]:={
a_**Subscript[int, r_][b_]/;FreeQ[a,r]:>Subscript[int, r][a**b],
Subscript[int, r_][b_]**a_/;FreeQ[a,r]:>Subscript[int, r][b**a],
c_ Subscript[int, r_][a_]/;FreeQ[c,r]:>Subscript[int, r][c a],
Subscript[int, r_][a_]+Subscript[int, r_][b_]:>Subscript[int, r][a+b],
Subscript[(op:tr|rot), v__]@Subscript[int, r_]@a_:>Subscript[int, r]@Subscript[op, v]@a
}
moveOpOutside[op_]:={
Subscript[op, v__][a_]**b_:>Subscript[op, v][a**b],
Subscript[op, v__][a_] b_/;rank[b]==0:>Subscript[op, v][a b]
}
moveOpInside[op_]:={
Subscript[op, v__][a_ b_]/;rank[b]==0:>Subscript[op, v][a] b,
Subscript[op, v__][a_ +b_]:>Subscript[op, v][a]+Subscript[op, v][b],
Subscript[op, v__][(a_ +b_)**c_]:>Subscript[op, v][a**c]+Subscript[op, v][b**c]
}
simplifications:={
a_**b_/;rank[a]==0||rank[b]==0:>a b,
a_**(b_ c_)/;rank[c]==0:>c a**b,
(c_ a_)**b_/;rank[c]==0:>c a**b,
Subscript[rot, 1][a_]:>a,
Subscript[grad, r_][(op:A|B)[r_]]:>Del[op]
}
(* writing G as a derivative *)
Subscript[integrateG, r_][g[R_]]:=1/(2 D[R,r]) Subscript[tr, 1,2]@Subscript[grad, r][R g[R]]
Subscript[integrateG, r_][R_ g[R_]]:=1/(3 D[R,r]) Subscript[tr, 1,2]@Subscript[grad, r][R**R g[R]]
vol2surface=Join[{
(* volume integral of a gradient *)
Subscript[vol, r_]@Subscript[grad, r_][a_]:>Subscript[surf, r][Subscript[n, r]**a],
(* move surface integration outside of a volume integral or gradient *)
Subscript[(op:vol|grad), rp_]@Subscript[surf, r_]@a_/;FreeQ[rp,r]:>Subscript[surf, r]@Subscript[op, rp]@a,
(* Reduce the order of a linear function *)
Subscript[grad, r_][G_]Q_/;!FreeQ[G,g]&&!FreeQ[Q,r]:>Subscript[grad, r][G Q]-Subscript[rot, Sequence@@Range[rank[G]+1]][G**Subscript[grad, r][Q]],
(* volume integral of (r-rp)^n g *)
Subscript[vol, r_][g[R_]]:>Subscript[vol, r][Subscript[integrateG, r][g[R]]],
Subscript[vol, r_][R_ g[R_]]:>Subscript[vol, r][Subscript[integrateG, r][R g[R]]],
(* reorder surface integrals *)
Subscript[surf, r]@Subscript[surf, rp]@a_:>Subscript[surf, rp]@Subscript[surf, r]@a
},
moveLinearOutside[vol],
moveLinearInside[surf],
moveOpOutside[rot],
simplifications
];
vol2surface2=Join[
moveOpInside[rot],
moveOpInside[tr],
simplifications];



(*Numerical computation of Subscript[\[ScriptCapitalI],k]*)(*The integrals are over r,so use r0 as r'*)
ClearAll[surfaceIntegrand]
surfaceIntegrand[Subscript[\[ScriptCapitalI],k_]]:=Nest[(r-r0)**#&,1,k] g[r-r0]



